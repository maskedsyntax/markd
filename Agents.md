# Markd Requirements Document

## Overview

Markd is a fast, clean, and minimal Markdown editor written in Rust. It features a split-pane interface: the left pane is a Markdown text editor, and the right pane renders GitHub-style Markdown output.

The application must be built using GPUI (the Rust-native GPU-accelerated UI framework used by Zed). It should feel modern, fluid, and highly responsive on Linux, including Pop!_OS, while maintaining strong architectural discipline and avoiding low-quality autogenerated code.

The goal is to deliver a responsive, lightweight, and polished editor that follows strong architectural practices and remains extensible for future features.

---

## Features

### Core Editor

* Left pane: plain-text Markdown editor.
* Right pane: Markdown renderer following GitHub-flavored Markdown rules.
* Both panes should resize via draggable divider.
* “Render” button: manually triggers Markdown rendering.
* “Auto-render” toggle: when enabled, re-renders on text change with debounce (e.g., 150 ms).
* Syntax highlighting for Markdown (headings, lists, emphasis, code blocks, tables).
* Line numbers in the editor.
* Status bar: cursor position, selected line count, file encoding, autosave state.
* Autosave support for local files.

### File Management

* New File
* Open File
* Save
* Save As
* Recent Files list
* Ability to open multiple files in separate tabs

### Editing Features

* Undo / Redo
* Cut / Copy / Paste
* Select All
* Duplicate Line
* Move Line Up / Down
* Find and Replace (with regex option)
* Toggle Word Wrap
* Toggle Line Numbers
* Toggle Preview Pane visibility

### Keyboard Shortcuts

(Use common shortcuts expected in editors like Mousepad, VSCode, etc.)

* Ctrl+N: New
* Ctrl+O: Open
* Ctrl+S: Save
* Ctrl+Shift+S: Save As
* Ctrl+Q: Quit
* Ctrl+Z: Undo
* Ctrl+Y: Redo
* Ctrl+X: Cut
* Ctrl+C: Copy
* Ctrl+V: Paste
* Ctrl+A: Select All
* Ctrl+F: Find
* Ctrl+H: Replace
* Ctrl+D: Duplicate Line
* Alt+Up / Alt+Down: Move Line Up/Down
* Ctrl+: Toggle Preview Pane
* Ctrl+R: Render
* Ctrl+Shift+R: Toggle Auto-Render

### Rendering Engine

* Markdown should be rendered using a GitHub-flavored Markdown compliant library in Rust (e.g. `pulldown-cmark` plus extensions or `comrak`).
* Renderer must support:

  * Headings
  * Lists
  * Code blocks with syntax highlighting (use `syntect` for performance)
  * Blockquotes
  * Tables
  * Links
  * Images
  * Task lists
  * Inline code
  * Bold/italic
* Rendering should output sanitized HTML for safety.
* HTML should be rendered inside a GPU-accelerated preview surface within GPUI.
* Avoid re-rendering entire DOM unnecessarily. Use diffing or replace-in-place strategies

### Performance Expectations

* Editor must remain responsive for files up to 2 MB.
* Auto-render must be debounced to avoid excessive CPU usage.
* Rendering must run in a background worker.
* UI thread must never block.
* Avoid unnecessary document cloning.
* Preview updates must be efficient and incremental where possible.

---

## UI / UX Requirements

### Layout

* Two-pane layout with adjustable vertical divider.
* Tab bar at the top for multiple files.
* Clean, distraction-free interface.
* Toolbar under menu bar containing:

  * Render button
  * Auto-render toggle
  * Word-wrap toggle
  * Preview toggle

### Menu Bar

#### File

* New
* Open
* Save
* Save As
* Recent Files
* Quit

#### Edit

* Undo
* Redo
* Cut
* Copy
* Paste
* Duplicate line
* Move line
* Preferences

#### View

* Toggle Word Wrap
* Toggle Line Numbers
* Toggle Preview Pane
* Zoom In
* Zoom Out
* Reset Zoom

#### Help

* About

### Preferences Window

* Default font family & size for editor
* Tab width (spaces)
* Syntax highlighting toggle
* Enable autosave
* Autosave interval
* Default auto-render state
* Sync scroll toggle

### Preview Pane Behavior

* Should scroll independently from the editor unless “sync scroll” is enabled.
* Option for “sync scroll” in toolbar or preferences.
* Styling should visually resemble GitHub Markdown.
* Smooth scrolling using GPU acceleration.

---

## Architecture

### Overall Structure

* Follow a clean architecture approach:

  * UI layer using GPUI components only
  * Application layer handling editor state and commands
  * Core layer handling Markdown parsing and rendering
  * IO layer handling file persistence
UI must not contain business logic.

* Ensure modularity for:
  * PDF export
  * Plugin system
  * Custom render backends
  * Git integration

### Threading Model

* UI thread handles rendering and input only.
* Markdown parsing runs in background worker.
* Syntax highlighting can use parallelism where beneficial.
* Autosave handled by timed background task.
* Use Rust channels for thread communication.
No shared mutable state without synchronization primitives.

### Error Handling

* No panics in production build.
* All fallible operations return `Result` with descriptive error types.
* Non-blocking error dialogs for user-facing errors.
* Log internal errors but present user-friendly messages.

### Logging

* Use a lightweight logging crate (e.g. `tracing`) with rotating logs.
* Log rendering duration for performance diagnostics.
* Debug mode can enable verbose logs.

### File Persistence

* Support UTF-8 exclusively.
* Detect BOM and warn if present.
* Support temp recovery files.
* Clean shutdown ensures state persistence.

---

## Tooling and Dependencies

### Language

* Rust stable

### GUI Framework

* GPUI
* Follow GPUI best practices:
  * Declarative component design
  * Immutable state updates
  * Minimal re-rendering
  * Strong typing for UI state

### Dependencies

* gpui
* comrak or pulldown-cmark
* syntect
* notify
* serde
* toml
* tracing
* rayon or tokio

---

## Coding Guidelines for the Agent

### Must-Follow Rules

* No autogenerated or low-effort code.
* All modules should have clear responsibilities.
* Follow idiomatic Rust patterns.
* Use strong typing, enums, structs, traits instead of magic strings.
* Functions must be small and focused.
* Every important function must have a Rustdoc comment.
* No deep nesting: refactor early.
* Avoid unnecessary `.clone()` calls.
* Keep UI code clean; avoid business logic in UI callbacks.
* Provide integration points for later plugin system.

### Style

* Use `clippy` and `rustfmt` clean builds.
* Zero unsafe code unless absolutely required.
* Code should prioritize clarity, maintainability, and performance.

---

## Future Extensions

* PDF export
* Git integration
* Themes (light, dark, sepia)
* Plugin system
* Custom Markdown extensions
* Live HTML export window
* Command palette
* Vim mode

---

DO NOT EVER COMMIT THIS FILE TO THE REPOSITORY
